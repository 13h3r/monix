/*
 * Copyright (c) 2014-2016 by its authors. Some rights reserved.
 * See the project homepage at: https://monix.io
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package monix.streams

import java.io.PrintStream

import monix.execution.cancelables.BooleanCancelable
import monix.streams.ObservableLike.{Operator, Transformer}
import monix.streams.internal.builders.{CombineLatest2Observable, Zip2Observable}
import monix.streams.internal.operators
import monix.streams.internal.operators2._
import monix.streams.observers.Subscriber
import scala.concurrent.duration.FiniteDuration
import scala.language.higherKinds

/** Defines the available operations for observable-like instances.
  *
  * @define concatMergeDifference The difference between the `concat` operation
  *         and `merge`is that `concat` cares about the ordering of sequences
  *         (e.g. all items emitted by the first observable in the sequence
  *         will come before the elements emitted by the second observable),
  *         whereas `merge` doesn't care about that (elements get
  *         emitted as they come). Because of back-pressure applied to
  *         observables, `concat` is safe to use in all contexts, whereas
  *         `merge` requires buffering.
  * @define concatDescription Concatenates the sequence
  *         of observables emitted by the source into one observable,
  *         without any transformation.
  *
  *         You can combine the items emitted by multiple observables
  *         so that they act like a single sequence by using this
  *         operator.
  *
  *         $concatMergeDifference
  * @define delayErrorsDescription This version is reserving onError
  *         notifications until all of the observables complete and only
  *         then passing the issued errors(s) downstream. Note that
  *         the streamed error is a
  *         [[monix.streams.exceptions.CompositeException CompositeException]],
  *         since multiple errors from multiple streams can happen.
  * @define concatReturn an observable that emits items that are the result of
  *         flattening the items emitted by the observables emitted by the source
  * @define switchDescription Convert an observable that emits observables
  *         into a single observable that emits the items emitted by
  *         the most-recently-emitted of those observables.
  * @define switchMapDescription Returns a new observable that emits the items
  *         emitted by the observable most recently generated by the
  *         mapping function.
  */
abstract class ObservableLike[+A, Self[+T] <: ObservableLike[T, Self]] { self: Self[A] =>
  /** Transforms the source using the given operator function. */
  def lift[B](operator: Operator[A,B]): Self[B]

  /** Transforms the source using the given transformer function. */
  def transform[B](transformer: Transformer[A,B]): Self[B]

  /** Concatenates the source with another observable.
    *
    * Ordering of subscription is preserved, so the second observable
    * starts only after the source observable is completed
    * successfully with an `onComplete`. On the other hand, the second
    * observable is never subscribed if the source completes with an
    * error.
    */
  def ++[B >: A](other: => Observable[B]): Self[B] =
    self.transform(self => Observable.concat(self, other))

  /** Periodically gather items emitted by an observable into bundles
    * and emit these bundles rather than emitting the items one at a
    * time. This version of `buffer` is emitting items once the
    * internal buffer has reached the given count.
    *
    * If the source observable completes, then the current buffer gets
    * signaled downstream. If the source triggers an error then the
    * current buffer is being dropped and the error gets propagated
    * immediately.
    *
    * @param count the maximum size of each buffer before it should
    *        be emitted
    */
  def buffer(count: Int): Self[Seq[A]] =
    bufferSkipped(count, count)

  /** Returns an observable that emits buffers of items it collects from
    * the source observable. The resulting observable emits buffers
    * every `skip` items, each containing `count` items.
    *
    * If the source observable completes, then the current buffer gets
    * signaled downstream. If the source triggers an error then the
    * current buffer is being dropped and the error gets propagated
    * immediately.
    *
    * For `count` and `skip` there are 3 possibilities:
    *
    *  1. in case `skip == count`, then there are no items dropped and
    *      no overlap, the call being equivalent to `buffer(count)`
    *  2. in case `skip < count`, then overlap between buffers
    *     happens, with the number of elements being repeated being
    *     `count - skip`
    *  3. in case `skip > count`, then `skip - count` elements start
    *     getting dropped between windows
    *
    * @param count the maximum size of each buffer before it should
    *        be emitted
    * @param skip how many items emitted by the source observable should
    *        be skipped before starting a new buffer. Note that when
    *        skip and count are equal, this is the same operation as
    *        `buffer(count)`
    */
  def bufferSkipped(count: Int, skip: Int): Self[Seq[A]] =
    self.lift(new BufferOperator(count, skip))

  /** Periodically gather items emitted by an observable into bundles
    * and emit these bundles rather than emitting the items one at a
    * time.
    *
    * This version of `buffer` emits a new bundle of items
    * periodically, every timespan amount of time, containing all
    * items emitted by the source Observable since the previous bundle
    * emission.
    *
    * If the source observable completes, then the current buffer gets
    * signaled downstream. If the source triggers an error then the
    * current buffer is being dropped and the error gets propagated
    * immediately.
    *
    * @param timespan the interval of time at which it should emit
    *        the buffered bundle
    */
  def bufferTimed(timespan: FiniteDuration) =
    bufferTimedOrCounted(timespan, 0)

  /** Periodically gather items emitted by an observable into bundles
    * and emit these bundles rather than emitting the items one at a
    * time.
    *
    * The resulting observable emits connected, non-overlapping
    * buffers, each of a fixed duration specified by the `timespan`
    * argument or a maximum size specified by the `maxSize` argument
    * (whichever is reached first).
    *
    * If the source observable completes, then the current buffer gets
    * signaled downstream. If the source triggers an error then the
    * current buffer is being dropped and the error gets propagated
    * immediately.
    *
    * @param timespan the interval of time at which it should emit
    *        the buffered bundle
    * @param maxSize is the maximum bundle size
    */
  def bufferTimedOrCounted(timespan: FiniteDuration, maxSize: Int): Self[Seq[A]] =
    self.lift(new BufferTimedOperator(timespan, maxSize))

  /** Applies the given partial function to the source
    * for each element for which the given partial function is defined.
    *
    * @param pf the function that filters and maps the source
    *
    * @return an observable that emits the transformed items by the
    *         given partial function
    */
  def collect[B](pf: PartialFunction[A, B]): Self[B] =
    self.lift(new CollectOperator(pf))

  /** Creates a new observable from the source and another given
    * observable, by emitting elements combined in pairs. If one of
    * the observables emits fewer events than the other, then the rest
    * of the unpaired events are ignored.
    *
    * See [[zip]] for an alternative that pairs the items in strict sequence.
    *
    * @param other is an observable that gets paired with the source
    */
  def combineLatest[B](other: Observable[B]): Self[(A,B)] =
    self.transform(self => new CombineLatest2Observable[A,B,(A,B)](self, other)((a,b) => (a,b)))

  /** Creates a new observable from the source and another given
    * observable, by emitting elements combined in pairs. If one of
    * the observables emits fewer events than the other, then the rest
    * of the unpaired events are ignored.
    *
    * See [[zipWith]] for an alternative that pairs the items
    * in strict sequence.
    *
    * @param other is an observable that gets paired with the source
    * @param f is a mapping function over the generated pairs
    */
  def combineLatestWith[B,R](other: Observable[B])(f: (A,B) => R): Self[R] =
    self.transform(self => new CombineLatest2Observable[A,B,R](self, other)(f))

  /** Ignores all items emitted by the source Observable and only calls
    * onCompleted or onError.
    *
    * @return an empty Observable that only calls onCompleted or onError,
    *         based on which one is called by the source Observable
    */
  def completed: Self[Nothing] =
    self.lift(CompletedOperator)

  /** $concatDescription
    *
    * @return $concatReturn
    */
  def concat[B](implicit ev: A <:< Observable[B]): Self[B] =
    concatMap[B](x => x)

  /** Applies a function that you supply to each item emitted by the
    * source observable, where that function returns observables,
    * and then concatenating those resulting sequences and
    * emitting the results of this concatenation.
    *
    * $concatMergeDifference
    */
  def concatMap[B](f: A => Observable[B]): Self[B] =
    self.transform(self => new ConcatMapObservable[A,B](self, f, delayErrors = false))

  /** Applies a function that you supply to each item emitted by the
    * source observable, where that function returns sequences that
    * [[CanObserve can be observed]], and then concatenating those
    * resulting sequences and emitting the results of this concatenation.
    *
    * This version uses the [[CanObserve]] type-class for concatenating
    * asynchronous sequences that can be converted to observables.
    *
    * $concatMergeDifference
    */
  def concatMapF[B, F[_] : CanObserve](f: A => F[B]): Self[B] =
    concatMap(a => CanObserve[F].observable[B](f(a)))

  /** $concatDescription
    *
    * $delayErrorsDescription
    *
    * @return $concatReturn
    */
  def concatDelayError[B](implicit ev: A <:< Observable[B]): Self[B] =
    concatMapDelayError(x => x)

  /** Applies a function that you supply to each item emitted by the
    * source observable, where that function returns sequences
    * and then concatenating those resulting sequences and emitting the
    * results of this concatenation.
    *
    * $delayErrorsDescription
    *
    * @param f a function that, when applied to an item emitted by
    *        the source, returns an observable
    *
    * @return $concatReturn
    */
  def concatMapDelayError[B](f: A => Observable[B]): Self[B] =
    self.transform(self => new ConcatMapObservable[A,B](self, f, delayErrors = true))

  /** Applies a function that you supply to each item emitted by the
    * source observable, where that function returns sequences that
    * [[CanObserve can be observed]], and then concatenating those
    * resulting sequences and emitting the results of this concatenation.
    *
    * $delayErrorsDescription
    *
    * This version of [[concatMapDelayError]] uses the [[CanObserve]]
    * type-class for concatenating asynchronous sequences that can be
    * converted to observables.
    *
    * @param f a function that, when applied to an item emitted by
    *        the source, returns an observable
    *
    * @return $concatReturn
    */
  def concatMapDelayErrorF[B, F[_] : CanObserve](f: A => F[B]): Self[B] =
    concatMapDelayError(a => CanObserve[F].observable(f(a)))

  /** Only emit an item from an observable if a particular timespan has
    * passed without it emitting another item.
    *
    * Note: If the source observable keeps emitting items more
    * frequently than the length of the time window, then no items will
    * be emitted by the resulting observable.
    *
    * @param timeout the length of the window of time that must pass after
    *        the emission of an item from the source observable in
    *        which that observable emits no items in order for the
    *        item to be emitted by the resulting observable
    *
    * @see [[echoOnce]] for a similar operator that also mirrors
    *     the source observable
    */
  def debounce(timeout: FiniteDuration): Self[A] =
    self.transform(self => new DebounceObservable(self, timeout, repeat = false))

  /** Doesn't emit anything until a `timeout` period passes without the
    * source emitting anything. When that timeout happens, we
    * subscribe to the observable generated by the given function, an
    * observable that will keep emitting until the source will break
    * the silence by emitting another event.
    *
    * Note: If the source observable keeps emitting items more
    * frequently than the length of the time window, then no items
    * will be emitted by the resulting Observable.
    *
    * @param f is a function that receives the last element generated
    *        by the source, generating an observable to be subscribed
    *        when the source is timing out
    * @param timeout the length of the window of time that must pass after
    *        the emission of an item from the source Observable in
    *        which that Observable emits no items in order for the
    *        item to be emitted by the resulting Observable
    */
  def debounceTo[B](timeout: FiniteDuration, f: A => Observable[B]): Self[B] =
    self.debounce(timeout).flatMapLatest(t => f(t))

  /** Emits the last item from the source Observable if a particular
    * timespan has passed without it emitting another item, and keeps
    * emitting that item at regular intervals until the source breaks
    * the silence.
    *
    * So compared to regular [[debounceTo]] this version
    * keeps emitting the last item of the source.
    *
    * Note: If the source Observable keeps emitting items more
    * frequently than the length of the time window then no items will
    * be emitted by the resulting Observable.
    *
    * @param period the length of the window of time that must pass after
    *        the emission of an item from the source Observable in
    *        which that Observable emits no items in order for the
    *        item to be emitted by the resulting Observable at regular
    *        intervals, also determined by period
    *
    * @see [[echoRepeated]] for a similar operator that also mirrors
    *     the source observable
    */
  def debounceRepeated(period: FiniteDuration): Self[A] =
    self.transform(self => new DebounceObservable(self, period, repeat = true))

  /** Emit items from the source, or emit a default item if
    * the source completes after emitting no items.
    */
  def defaultIfEmpty[B >: A](default: => B): Self[B] =
    self.lift(new DefaultIfEmptyOperator[B](default))

  /** Delays emitting the final `onComplete` event by the specified amount. */
  def delayOnComplete(delay: FiniteDuration): Self[A] =
    self.transform(self => new DelayOnCompleteObservable(self, delay))

  /** Returns an Observable that emits the items emitted by the source
    * Observable shifted forward in time by a specified delay.
    *
    * Each time the source Observable emits an item, delay starts a
    * timer, and when that timer reaches the given duration, the
    * Observable returned from delay emits the same item.
    *
    * NOTE: this delay refers strictly to the time between the
    * `onNext` event coming from our source and the time it takes the
    * downstream observer to get this event. On the other hand the
    * operator is also applying back-pressure, so on slow observers
    * the actual time passing between two successive events may be
    * higher than the specified `duration`.
    *
    * @param duration - the delay to shift the source by
    *
    * @return the source Observable shifted in time by the specified delay
    */
  def delayOnNext(duration: FiniteDuration): Self[A] =
    self.transform(self => new DelayByTimespanObservable[A](self, duration))

  /** Returns an Observable that emits the items emitted by the source
    * Observable shifted forward in time.
    *
    * This variant of `delay` sets its delay duration on a per-item
    * basis by passing each item from the source Observable into a
    * function that returns an Observable and then monitoring those
    * Observables. When any such Observable emits an item or
    * completes, the Observable returned by delay emits the associated
    * item.
    *
    * @param selector is a function that returns an Observable for
    *        each item emitted by the source Observable, which is then
    *        used to delay the emission of that item by the resulting
    *        Observable until the Observable returned from `selector`
    *        emits an item
    *
    * @return the source Observable shifted in time by
    *         the specified delay
    */
  def delayOnNextBySelector[B](selector: A => Observable[B]): Self[A] =
    self.transform(self => new DelayBySelectorObservable[A,B](self, selector))

  /** Returns an observable that emits the items emitted by the source
    * observable shifted forward in time.
    *
    * This variant of `delay` sets its delay duration on a per-item
    * basis by passing each item from the source Observable into a
    * function that returns an Observable and then monitoring those
    * Observables. When any such Observable emits an item or
    * completes, the Observable returned by delay emits the associated
    * item.
    *
    * @param selector is a function that returns an Observable for
    *        each item emitted by the source Observable, which is then
    *        used to delay the emission of that item by the resulting
    *        Observable until the Observable returned from `selector`
    *        completes
    *
    * @return the source Observable shifted in time by
    *         the specified delay
    */
  def delayOnNextBySelectorF[B, F[_] : CanObserve](selector: A => F[B]): Self[A] =
    delayOnNextBySelector(a => CanObserve[F].observable(selector(a)))

  /** Hold an Observer's subscription request for a specified amount of
    * time before passing it on to the source Observable.
    *
    * @param timespan is the time to wait before the subscription
    *        is being initiated.
    */
  def delaySubscription(timespan: FiniteDuration): Self[A] =
    self.transform(self => new DelaySubscriptionByTimespanObservable(self, timespan))

  /** Hold an Observer's subscription request until the given `trigger`
    * observable either emits an item or completes, before passing it
    * on to the source Observable.
    *
    * If the given `trigger` completes in error, then the subscription is
    * terminated with `onError`.
    *
    * @param trigger the observable that must either emit an item or
    *        complete in order for the source to be subscribed.
    */
  def delaySubscriptionWith[B, F[_] : CanObserve](trigger: F[B]): Self[A] =
    self.transform(self => new DelaySubscriptionWithTriggerObservable(self, trigger))

  /** Executes the given callback if the downstream observer has
    * canceled the streaming by returning `Cancel` as a result of `onNext`.
    */
  def doOnCancel(cb: => Unit): Self[A] =
    self.lift(new DoWorkOnCancelOperator[A](cb))

  /** Executes the given callback when the stream has ended, but before
    * the complete event is emitted.
    *
    * @param cb the callback to execute when the subscription is canceled
    */
  def doOnComplete(cb: => Unit): Self[A] =
    self.lift(new DoWorkOnCompleteOperator[A](cb))

  /** Executes the given callback when the stream is interrupted with an
    * error, before the `onError` event is emitted downstream.
    *
    * NOTE: should protect the code in this callback, because if it
    * throws an exception the `onError` event will prefer signaling
    * the original exception and otherwise the behavior is undefined.
    */
  def doOnError(cb: Throwable => Unit): Self[A] =
    self.lift(new DoOnErrorOperator[A](cb))

  /** Executes the given callback for each element generated by the
    * source Observable, useful for doing side-effects.
    *
    * @return a new Observable that executes the specified
    *         callback for each element
    */
  def doOnNext(cb: A => Unit): Self[A] =
    self.lift(new DoOnNextOperator[A](cb))

  /** Executes the given callback only for the first element generated
    * by the source Observable, useful for doing a piece of
    * computation only when the stream starts.
    *
    * @return a new Observable that executes the specified callback
    *         only for the first element
    */
  def doOnStart(cb: A => Unit): Self[A] =
    self.lift(new DoOnStartOperator[A](cb))

  /** Suppress the duplicate elements emitted by the source Observable.
    *
    * WARNING: this requires unbounded buffering.
    */
  def distinct: Self[A] =
    self.lift(new DistinctOperator[A])

  /** Given a function that returns a key for each element emitted by
    * the source Observable, suppress duplicates items.
    *
    * WARNING: this requires unbounded buffering.
    */
  def distinctByKey[K](key: A => K): Self[A] =
    self.lift(new DistinctByKeyOperator(key))

  /** Suppress duplicate consecutive items emitted by the source
    * Observable
    */
  def distinctUntilChanged: Self[A] =
    self.lift(new DistinctUntilChangedOperator[A])

  /** Suppress duplicate consecutive items emitted by the source
    * Observable
    */
  def distinctUntilChangedByKey[K](key: A => K): Self[A] =
    self.lift(new DistinctUntilChangedByKeyOperator(key))

  /** Drops the first `n` elements (from the start).
    *
    * @param n the number of elements to drop
    *
    * @return a new Observable that drops the first ''n'' elements
    *         emitted by the source
    */
  def drop(n: Int): Self[A] =
    self.lift(new DropLeftOperator(n))

  /** Creates a new observable that drops the events of the source, only
    * for the specified `timestamp` window.
    *
    * @param timespan the window of time during which the new observable
    *        must drop events emitted by the source
    */
  def dropByTimespan(timespan: FiniteDuration): Self[A] =
    self.transform(self => new DropByTimespanObservable(self, timespan))

  /** Discard items emitted by the source until a second
    * observable emits an item or completes.
    *
    * If the `trigger` observable completes in error, then the
    * resulting observable will also end in error when it notices
    * it (next time an element is emitted by the source).
    *
    * @param trigger the observable that has to emit an item before the
    *        source begin to be mirrored by the resulting observable
    */
  def dropUntil[F[_] : CanObserve](trigger: F[_]): Self[A] =
    self.transform(self => new DropUntilObservable(self, trigger))

  /** Drops the longest prefix of elements that satisfy the given
    * predicate and returns a new observable that emits the rest.
    */
  def dropWhile(p: A => Boolean): Self[A] =
    self.lift(new DropByPredicateOperator(p))

  /** Drops the longest prefix of elements that satisfy the given
    * function and returns a new observable that emits the rest. In
    * comparison with [[dropWhile]], this version accepts a function
    * that takes an additional parameter: the zero-based index of the
    * element.
    */
  def dropWhileWithIndex(p: (A, Int) => Boolean): Self[A] =
    self.lift(new DropByPredicateWithIndexOperator(p))

  /** Utility that can be used for debugging purposes.
    */
  def dump(prefix: String, out: PrintStream = System.out): Self[A] =
    self.transform(self => new DumpObservable[A](self, prefix, out))

  /** Emits the given exception instead of `onComplete`.
    *
    * @param error the exception to emit onComplete
    *
    * @return a new Observable that emits an exception onComplete
    */
  def endWithError(error: Throwable): Self[A] =
    self.lift(new EndWithErrorOperator[A](error))

  /** Returns an observable that emits a single Throwable, in case an
    * error was thrown by the source, otherwise it isn't
    * going to emit anything.
    */
  def failed: Self[Throwable] =
    self.lift(FailedOperator)

  /** Only emits those items for which the given predicate holds.
    *
    * @param p a function that evaluates the items emitted by the source
    *        returning `true` if they pass the filter
    *
    * @return a new observable that emits only those items in the source
    *         for which the filter evaluates as `true`
    */
  def filter(p: A => Boolean): Self[A] =
    self.lift(new FilterOperator(p))

  /** Applies a function that you supply to each item emitted by the
    * source observable, where that function returns sequences that
    * [[CanObserve can be observed]], and then concatenating those
    * resulting sequences and emitting the results of this concatenation.
    *
    * Alias for [[concatMap]].
    *
    * $concatMergeDifference
    */
  def flatMap[B](f: A => Observable[B]): Self[B] =
    self.concatMap(f)

  /** Applies a function that you supply to each item emitted by the
    * source observable, where that function returns sequences
    * and then concatenating those resulting sequences and emitting the
    * results of this concatenation.
    *
    * It's an alias for [[concatMapDelayError]].
    *
    * @param f a function that, when applied to an item emitted by
    *        the source Observable, returns an Observable
    *
    * @return an Observable that emits the result of applying the
    *         transformation function to each item emitted by the
    *         source Observable and concatenating the results of the
    *         Observables obtained from this transformation.
    */
  def flatMapDelayError[B](f: A => Observable[B]): Self[B] =
    concatMapDelayError(f)

  /** Applies a function that you supply to each item emitted by the
    * source observable, where that function returns sequences that
    * [[CanObserve can be observed]], and then concatenating those
    * resulting sequences and emitting the results of this concatenation.
    *
    * This version uses the [[CanObserve]] type-class for concatenating
    * asynchronous sequences that can be converted to observables.
    *
    * Alias for [[concatMapF]].
    *
    * $concatMergeDifference
    */
  def flatMapF[B, F[_] : CanObserve](f: A => F[B]): Self[B] =
    self.concatMap(a => CanObserve[F].observable(f(a)))

  /** An alias of [[switchMap]].
    *
    * $switchMapDescription
    */
  def flatMapLatest[B](f: A => Observable[B]): Self[B] =
    self.switchMap(f)

  /** An alias of [[switchMapF]].
    *
    * $switchMapDescription
    */
  def flatMapLatestF[B, F[_] : CanObserve](f: A => F[B]): Self[B] =
    self.switchMapF(f)

  /** Applies a binary operator to a start value and to elements
    * produced by the source observable, going from left to right,
    * producing and concatenating observables along the way.
    *
    * It's the combination between [[scan]] and [[flatMap]].
    */
  def flatScan[R](initial: R)(op: (R, A) => Observable[R]): Self[R] =
    self.transform(self => new FlatScanObservable[A,R](self, initial, op, delayErrors = false))

  /** Applies a binary operator to a start value and to elements
    * produced by the source observable, going from left to right,
    * producing and concatenating observables along the way.
    *
    * It's the combination between [[scan]] and [[flatMap]].
    */
  def flatScanF[R,F[_] : CanObserve](initial: R)(op: (R, A) => F[R]): Self[R] =
    self.flatScan(initial)((state, a) => CanObserve[F].observable(op(state,a)))

  /** Applies a binary operator to a start value and to elements
    * produced by the source observable, going from left to right,
    * producing and concatenating observables along the way.
    *
    * This version of [[flatScan]] delays all errors until `onComplete`,
    * when it will finally emit a `CompositeException`.
    * It's the combination between [[scan]] and [[flatMapDelayError]].
    */
  def flatScanDelayError[R](initial: R)(op: (R, A) => Observable[R]): Self[R] =
    self.transform(self => new FlatScanObservable[A,R](self, initial, op, delayErrors = true))

  /** Applies a binary operator to a start value and to elements
    * produced by the source observable, going from left to right,
    * producing and concatenating observables along the way.
    *
    * This version of [[flatScan]] delays all errors until `onComplete`,
    * when it will finally emit a `CompositeException`.
    * It's the combination between [[scan]] and [[flatMapDelayError]].
    */
  def flatScanDelayErrorF[R, F[_]: CanObserve](initial: R)(op: (R, A) => F[R]): Self[R] =
    self.flatScanDelayError(initial)((state, a) => CanObserve[F].observable(op(state,a)))

  /** $concatDescription
    *
    * Alias for [[concat]].
    *
    * @return $concatReturn
    */
  def flatten[B](implicit ev: A <:< Observable[B]): Self[B] =
    concat

  /** Alias for [[switch]]
    *
    * $switchDescription
    */
  def flattenLatest[B](implicit ev: A <:< Observable[B]): Self[B] =
    self.switch

  /** Applies a binary operator to a start value and all elements of
    * this Observable, going left to right and returns a new
    * Observable that emits only one item before `onComplete`.
    */
  def foldLeft[R](initial: R)(op: (R, A) => R): Self[R] =
    self.lift(new FoldLeftOperator(initial, op))

  /** Alias for [[completed]]. Ignores all items emitted by
    * the source and only calls onCompleted or onError.
    *
    * @return an empty sequence that only calls onCompleted or onError,
    *         based on which one is called by the source Observable
    */
  def ignoreElements: Self[Nothing] =
    self.lift(CompletedOperator)

  /** Returns an Observable that emits true if the source Observable is
    * empty, otherwise false.
    */
  def isEmpty: Self[Boolean] =
    self.lift(IsEmptyOperator)

  /** Returns an Observable that emits false if the source Observable is
    * empty, otherwise true.
    */
  def nonEmpty: Self[Boolean] =
    self.lift(IsEmptyOperator).map(b => !b)

  /** Returns a new observable that applies the given function
    * to each item emitted by the source and emits the result.
    */
  def map[B](f: A => B): Self[B] =
    self.lift(new MapOperator(f))

  /** Returns an observable that mirrors the behavior of the source,
    * unless the source is terminated with an `onError`, in which
    * case the streaming of events fallbacks to an observable
    * emitting a single element generated by the backup function.
    *
    * The created Observable mirrors the behavior of the source
    * in case the source does not end with an error or if the
    * thrown `Throwable` is not matched.
    *
    * @param pf - a partial function that matches errors with a
    *           backup element that is emitted when the source
    *           throws an error.
    */
  def onErrorRecover[B >: A](pf: PartialFunction[Throwable, B]): Self[B] =
    onErrorRecoverWith { case elem if pf.isDefinedAt(elem) => Observable.now(pf(elem)) }

  /** Returns an Observable that mirrors the behavior of the source,
    * unless the source is terminated with an `onError`, in which case
    * the streaming of events continues with the specified backup
    * sequence generated by the given partial function.
    *
    * The created Observable mirrors the behavior of the source in
    * case the source does not end with an error or if the thrown
    * `Throwable` is not matched.
    *
    * @param pf is a partial function that matches errors with a
    *        backup throwable that is subscribed when the source
    *        throws an error.
    */
  def onErrorRecoverWith[B >: A](pf: PartialFunction[Throwable, Observable[B]]): Self[B] =
    self.transform(self => new OnErrorRecoverWithObservable(self, pf))

  /** Given a [[monix.streams.Pipe Pipe]], transform
    * the source observable with it.
    */
  def pipeThrough[I >: A, B](pipe: Pipe[I,B]): Self[B] =
    self.lift(new TransformOperator(pipe))

  /** Applies a binary operator to a start value and all elements of
    * this Observable, going left to right and returns a new
    * Observable that emits on each step the result of the applied
    * function.
    *
    * Similar to [[foldLeft]], but emits the state on each
    * step. Useful for modeling finite state machines.
    */
  def scan[R](initial: R)(f: (R, A) => R): Self[R] =
    self.lift(new ScanOperator(initial, f))

  /** $switchDescription */
  def switch[B](implicit ev: A <:< Observable[B]): Self[B] =
    self.switchMap(x => x)

  /** $switchMapDescription */
  def switchMap[B](f: A => Observable[B]): Self[B] =
    self.transform(self => new SwitchMapObservable[A,B](self, f))

  /** $switchMapDescription */
  def switchMapF[B, F[_] : CanObserve](f: A => F[B]): Self[B] =
    self.switchMap(a => CanObserve[F].observable(f(a)))

  /** Selects the first `n` elements (from the start).
    *
    * @param  n the number of elements to take
    *
    * @return a new Observable that emits only the first
    *         `n` elements from the source
    */
  def take(n: Long): Self[A] =
    self.lift(new TakeLeftOperator(n))

  /** Creates a new Observable that emits the events of the source, only
    * for the specified `timestamp`, after which it completes.
    *
    * @param timespan the window of time during which the new Observable
    *        is allowed to emit the events of the source
    */
  def takeByTimespan(timespan: FiniteDuration): Self[A] =
    self.transform(self => new TakeLeftByTimespanObservable(self, timespan))

  /** Creates a new observable that only emits the last `n` elements
    * emitted by the source.
    *
    * In case the source triggers an error, then the underlying
    * buffer gets dropped and the error gets emitted immediately.
    */
  def takeRight(n: Int): Self[A] =
    self.lift(new TakeRightOperator(n))

  /** Takes longest prefix of elements that satisfy the given predicate
    * and returns a new Observable that emits those elements.
    */
  def takeWhile(p: A => Boolean): Self[A] =
    self.lift(new TakeByPredicateOperator(p))

  /** Takes longest prefix of elements that satisfy the given predicate
    * and returns a new Observable that emits those elements.
    */
  def takeWhileNotCanceled(c: BooleanCancelable): Self[A] =
    self.lift(new TakeWhileNotCanceledOperator(c))

  /** Creates a new observable from this observable and another given
    * observable by combining their items in pairs in a strict sequence.
    *
    * So the first item emitted by the new observable will be the tuple of the
    * first items emitted by each of the source observables; the second item
    * emitted by the new observable will be a tuple with the second items
    * emitted by each of those observables; and so forth.
    *
    * See [[combineLatest]] for a more relaxed alternative that doesn't
    * combine items in strict sequence.
    *
    * @param other is an observable that gets paired with the source
    *
    * @return a new observable sequence that emits the paired items
    *         of the source observables
    */
  def zip[B](other: Observable[B]): Self[(A,B)] =
    self.transform(self => new Zip2Observable[A,B,(A,B)](self, other)((a,b) => (a,b)))

  /** Creates a new observable from this observable and another given
    * observable by combining their items in pairs in a strict sequence.
    *
    * So the first item emitted by the new observable will be the result
    * of the function applied to the first item emitted by each of
    * the source observables; the second item emitted by the new observable
    * will be the result of the function applied to the second item
    * emitted by each of those observables; and so forth.
    *
    * See [[combineLatestWith]] for a more relaxed alternative that doesn't
    * combine items in strict sequence.
    *
    * @param other is an observable that gets paired with the source
    * @param f is a mapping function over the generated pairs
    */
  def zipWith[B,R](other: Observable[B])(f: (A,B) => R): Self[R] =
    self.transform(self => new Zip2Observable[A,B,R](self, other)(f))

  /** Zips the emitted elements of the source with their indices. */
  def zipWithIndex: Self[(A, Long)] =
    self.lift(new ZipWithIndexOperator[A])
}

object ObservableLike {
  /** An `Operator` is a function for transforming observers,
    * that can be used for lifting observables.
    */
  type Operator[-I,+O] = Subscriber[O] => Subscriber[I]

  /** A `Transformer` is a function used for transforming observables */
  type Transformer[-A,+B] = Observable[A] => Observable[B]
}
